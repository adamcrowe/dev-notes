# dev-notes

[A Developer's notebook](http://alexkrupp.typepad.com/sensemaking/2012/09/program-above-and-beyond-your-actual-ability-by-using-freemind.html)

## Deep Work

* [Deep Work](deep-work.md): Priortize deep work over shallow work

## Engineering

* [Debugging & Asking Questions](Engineering/debugging.md)
* [Software Development Life Cycle](Engineering/SDLC.md)
* [Requirements Analysis](Engineering/requirements.md)
* [Estimation](Engineering/estimation.md)
* [Scrum](Engineering/scrum.md)
* [BDD](Engineering/BDD.md)

## Professional Development

* [What Makes a Great Software Engineer?](https://faculty.washington.edu/ajko/papers/Li2015GreatEngineers.pdf), Character, Decision Making, Team Work, Product Design
* [What Makes a Good Programmer?](https://henrikwarne.com/2014/06/30/what-makes-a-good-programmer/): Problem Decomposition, Testing, Naming, Consistency, Learning
* [The Joys of Maintenance Programming](http://typicalprogrammer.com/the-joys-of-maintenance-programming): "Maintenance programmers get to work with real users."

## Wisdom

> Deliver your customer a competitive advantage. Your only objective is: How can I help my customer win?
>
> &mdash; [Jack Welsh](https://www.google.com/search?hl=en&q=%22the+welch+way%22+podcast+businessweek&oq=%22the+welch+way%22+podcast+businessweek)

> Your job as a programmer is not writing code, your job is solving problems: software is a tool, a means to an end. Software becomes valuable because of the problems it solves.
>
> &mdash; [Itamar Turner-Trauring](https://codewithoutrules.com/2020/04/20/productivity-skills)

> A programmer does not primarily write code; rather he primarily writes to another programmer about his problem solution.
>
> &mdash; [Donald Knuth](http://archive.computerhistory.org/resources/text/Knuth_Don_X4100/PDF_index/k-9-pdf/k-9-u2769-1-Baker-What-Programmer-Does.pdf)

> It's harder to read code than to write it. This is why code reuse is so hard.
>
> &mdash; [Joel Spolsky](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i)

> Code that's easier to read gets read more and therefore gets more scrutiny. Because of that, if there are bugs, they're more likely to be found.
>
> &mdash; [Gordon Zhu](https://watchandcode.com/courses/77710/lectures/2001287)

> Consistent code formatting is worth fighting for.
>
> &mdash;[Jeff Atwood](https://blog.codinghorror.com/death-to-the-space-infidels)

> Deleted code is debugged code.
>
> &mdash; [Jeff Sickel](http://www.defprogramming.com/quotes-by/jeff-sickel)

> Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.
>
> &mdash; [Antoine de Saint Exupéry](https://en.wikipedia.org/wiki/Antoine_de_Saint-Exup%C3%A9ry)

> In describing what the code is supposed to do and observing what it actually does, any incongruity between these two becomes apparent.
>
> &mdash; [Rubber Duck Debugging](https://en.wikipedia.org/wiki/Rubber_duck_debugging)

> Duplication is far cheaper than the wrong abstraction.
>
> &mdash; [Sandi Metz](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)

> Gall's Law: A complex system that works is invariably found to have evolved from a simple system that worked.
>
> &mdash; [Gall's Law](<https://en.wikipedia.org/wiki/John_Gall_(author)#Gall.27s_law>)

> Hofstadter's Law: It always takes longer than you expect, even when you take into account Hofstadter’s Law.
>
> &mdash; [Hofstadter’s Law](https://en.wikipedia.org/wiki/Hofstadter%27s_law)

> Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
>
> &mdash; [Jamie Zawinski](http://regex.info/blog/2006-09-15/247)

> Why is programming fun? What delights may its practitioner expect as his reward? First is the sheer joy of making things. As the child delights in his mud pie, so the adult enjoys building things, especially things of his own design. I think this delight must be an image of God's delight in making things, a delight shown in the distinctness and newness of each leaf and each snowflake. Second is the pleasure of making things that are useful to other people. Deep within, we want others to use our work and to find it helpful. In this respect the programming system is not essentially different from the child's first clay pencil holder "for Daddy's office." Third is the fascination of fashioning complex puzzle-like objects of interlocking moving parts and watching them work in subtle cycles, playing out the consequences of principles built in from the beginning. The programmed computer has all the fascination of the pinball machine or the jukebox mechanism, carried to the ultimate. Fourth is the joy of always learning, which springs from the nonrepeating nature of the task. In one way or another the problem is ever new, and its solver learns something: sometimes practical, sometimes theoretical, and sometimes both. Finally, there is the delight of working in such a tractable medium. The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures.
>
> &mdash; [Fred Brooks, The Mythical Man-Month: Essays on Software Engineering](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)
